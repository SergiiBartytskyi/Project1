{"mappings":"AAAAA,QAAQC,IAAI","sources":["src/js/assync.js"],"sourcesContent":["console.log(333);\n\n// console.log(\"First log\");\n// console.log(\"Second log\");\n// console.log(\"Third log\");\n\n// Will run first\n// console.log(\"First log\");\n\n// setTimeout(() => {\n// \t// Will run last, after 2000 milliseconds\n// \tconsole.log(\"Second log\");\n// }, 1000);\n\n// // Will run second\n// setTimeout(() => {\n// \t// Will run last, after 2000 milliseconds\n// \tconsole.log(\"Third log\");\n// }, 900);\n\n// console.log(\"Fourth log\");\n//\n//\n\n//\n//\n// const button = document.querySelector(\"button\");\n\n// const onClick = () => {\n// \tconst timerId = setTimeout(() => {\n// \t\tconsole.log(\"I love async JS!\");\n// \t}, 2000);\n\n// \tconsole.log(timerId);\n// };\n\n// button.addEventListener(\"click\", onClick);\n//\n//\n\n//                              Скасування асинхронного виклику функції - clearTimeout(id)\n//                              --------------------------\n//\n// const greet = () => {\n// \tconsole.log(\"Hello!\");\n// };\n// const timerId = setTimeout(greet, 1000);\n// clearTimeout(timerId);\n//\n//\n\n//\n//\n//                              Інтервал - setInterval()\n//                                  ----------------------\n//\n//  const timerId = setInterval(callback, delay, arg1, arg2, ...);\n//\n// const startBtn = document.querySelector(\".js-start\");\n// const stopBtn = document.querySelector(\".js-stop\");\n// let timerId = null;\n\n// startBtn.addEventListener(\"click\", () => {\n// \ttimerId = setInterval(() => {\n// \t\tconsole.log(`I love async JS!  ${Math.round(Math.random() * 100)}`);\n// \t}, 1000);\n// });\n\n// stopBtn.addEventListener(\"click\", () => {\n// \tclearInterval(timerId);\n// \tconsole.log(`Interval with id ${timerId} has stopped!`);\n// });\n//\n//\n//\n\n//\n//\n//\n//                                      Date\n//                                      ----\n//\n// const date = new Date();\n\n// console.dir(date);\n// // \"Fri Jun 18 2021 15:01:35 GMT+0300 (Eastern European Summer Time)\" - Object\n\n// console.log(date.toString());\n// // \"Fri Jun 18 2021 15:01:35 GMT+0300 (Eastern European Summer Time)\" - String\n//\n//\n\n//\n//\n//                                  Unix time\n//                                  ---------\n//\n// console.log(new Date(0));\n// // \"Thu Jan 01 1970 03:00:00 GMT+0300 (Eastern European Standard Time)\"\n\n// console.log(new Date(1730005515996));\n// // \"Thu Jan 01 1970 03:00:15 GMT+0300 (Eastern European Standard Time)\"\n//\n//\n\n//\n//\n// Метод getTime() повертає числове значення цієї дати(timestamp) - кількість мілісекунд,\n//     що минула з півночі 1 січня 1970 року.\n\n// const date = new Date(\"March 30, 1986\");\n\n// console.log(date);\n// Sun Mar 30 1986 00:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// const newDate = date.getTime();\n\n// // console.log(date.getTime());\n// 1624021654154\n\n// console.log(newDate); // 512521200000\n\n// console.log(new Date(newDate));\n// Sun Mar 30 1986 00:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n//\n//\n\n//\n//\n//                                  Встановлення дати\n//                                  -----------------\n//\n// const teamMeetingDate = new Date(\"March 16, 2030\");\n// console.log(teamMeetingDate);\n// // \"Mon Mar 16 2030 00:00:00 GMT+0200 (Eastern European Standard Time)\"\n\n// const preciseTeamMeetingDate = new Date(\"March 16, 2030 14:25:00\");\n// console.log(preciseTeamMeetingDate);\n// // \"Mon Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)\"\n//\n//\n\n//\n//\n//                              Встановлення дати\n//                              -----------------\n//\n// new Date(\"2030-03-16\");\n// console.log(new Date(\"2030-03-16\"));\n// // Sat Mar 16 2030 01:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"2030-03\");\n// console.log(new Date(\"2030-03\"));\n// // Fri Mar 01 2030 01:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"2018\");\n// console.log(new Date(\"2018\"));\n// // Mon Jan 01 2018 01:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"03/16/2030\");\n// console.log(new Date(\"03/16/2030\"));\n// // Sat Mar 16 2030 00:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"2030/03/16\");\n// console.log(new Date(\"2030/03/16\"));\n// // Sat Mar 16 2030 00:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"2030/3/16\");\n// console.log(new Date(\"2030/3/16\"));\n// // Sat Mar 16 2030 00:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"March 16, 2030\");\n// console.log(new Date(\"March 16, 2030\"));\n// // Sat Mar 16 2030 00:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"March 16, 2030 14:25:00\");\n// console.log(new Date(\"March 16, 2030 14:25:00\"));\n// // Sat Mar 16 2030 14:25:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"2030-03-16 14:25:00\");\n// console.log(new Date(\"2030-03-16 14:25:00\"));\n// // Sat Mar 16 2030 14:25:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"2030-03-16T14:25:00\");\n// console.log(new Date(\"2030-03-16T14:25:00\"));\n// // Sat Mar 16 2030 14:25:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // new Date(\"16 March 2030\");\n// console.log(new Date(\"16 March 2030\"));\n// // Sat Mar 16 2030 00:00:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// Інший спосіб створення нових об'єктів - це передати сім чисел, які описують рік, місяць\n//     (починається з 0), день, години, хвилини, секунди і мілісекунди.Обов'язкові тільки\n//     перші три.\n\n// const date = new Date(2030, 2, 16, 14, 25, 0, 0);\n// console.log(date);\n// // Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)\n//\n//\n\n//\n//\n//                                      Геттери\n//                                      ------\n//\n// const date = new Date();\n// console.log(\"Date: \", date);\n// // Date:  Sat Mar 23 2024 09:36:13 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // Повертає день місяця від 1 до 31\n// console.log(\"getDate(): \", date.getDate());\n// // getDate():  23\n\n// // Повертає день тижня від 0 до 6\n// console.log(\"getDay(): \", date.getDay());\n// // getDay():  6\n\n// // Повертає місяць від 0 до 11\n// console.log(\"getMonth(): \", date.getMonth());\n// // getMonth():  2\n\n// // Повертає рік з 4 цифр\n// console.log(\"getFullYear(): \", date.getFullYear());\n// // getFullYear():  2024\n\n// // Повертає години\n// console.log(\"getHours(): \", date.getHours());\n// // getHours():  9\n\n// // Повертає хвилини\n// console.log(\"getMinutes(): \", date.getMinutes());\n// // getMinutes():  37\n\n// // Повертає секунди\n// console.log(\"getSeconds(): \", date.getSeconds());\n// // getSeconds():  37\n\n// // Повертає мілісекунди\n// console.log(\"getMilliseconds(): \", date.getMilliseconds());\n// // getMilliseconds():  370\n//\n//\n\n//\n//\n// Існують еквівалентні версії цих методів, які повертають значення у форматі\n// UTC(Coordinated Universal Time), а не адаптовані до поточного часового поясу користувача.\n\n// const date = new Date();\n// console.log(\"Date: \", date);\n// // Date:  Sat Mar 23 2024 09:52:32 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// // Повертає день місяця від 1 до 31\n// console.log(\"getUTCDate(): \", date.getUTCDate());\n// // getUTCDate():  23\n\n// // Повертає день тижня від 0 до 6\n// console.log(\"getUTCDay(): \", date.getUTCDay());\n// // getUTCDay():  6\n\n// // Повертає місяць від 0 до 11\n// console.log(\"getUTCMonth(): \", date.getUTCMonth());\n// // getUTCMonth():  2\n\n// // Повертає рік з 4 цифр\n// console.log(\"getUTCFullYear(): \", date.getUTCFullYear());\n// // getUTCFullYear():  2024\n\n// // Повертає години\n// console.log(\"getUTCHours(): \", date.getUTCHours());\n// // getUTCHours():  8\n\n// // Повертає хвилини\n// console.log(\"getUTCMinutes(): \", date.getUTCMinutes());\n// // getUTCMinutes():  53\n\n// // Повертає секунди\n// console.log(\"getUTCSeconds(): \", date.getUTCSeconds());\n// // getUTCSeconds():  47\n\n// // Повертає мілісекунди\n// console.log(\"getUTCMilliseconds(): \", date.getUTCMilliseconds());\n// // getUTCMilliseconds():  881\n//\n//\n\n//\n//\n//                                  Сеттери\n//                                  -------\n//\n// const date = new Date(\"March 16, 2030 14:25:00\");\n// console.log(date);\n// Sat Mar 16 2030 14:25:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// date.setMinutes(50);\n// console.log(date.setMinutes(50));\n// // 1899899400000\n\n// console.log(date);\n// // // Sat Mar 16 2030 14:50:00 GMT+0100 (за центральноєвропейським стандартним часом)\n\n// date.setFullYear(2040, 4, 8);\n// console.log(date.setFullYear(2040, 4, 8));\n// // 2220094200000\n\n// console.log(date);\n// // Tue May 08 2040 14:50:00 GMT+0200 (за центральноєвропейським літнім часом)\n//\n//\n\n//\n//\n//                                  Форматування дати\n//                                  ----------------\n//\n// toString() - повертає дату повністю;\n// toDateString() - повертає дату;\n// toTimeString() - повертає час;\n//\n// const date = new Date(\"March 16, 2030 14:25:00\");\n\n// date.toString();\n// // \"Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)\"\n\n// date.toTimeString();\n// // \"14:25:00 GMT+0200 (Eastern European Standard Time)\"\n\n// date.toLocaleTimeString();\n// // \"2:25:00 PM\"\n\n// date.toUTCString();\n// // \"Sat, 16 Mar 2030 12:25:00 GMT\"\n\n// date.toDateString();\n// // \"Sat Mar 16 2030\"\n\n// date.toISOString();\n// // \"2030-03-16T12:25:00.000Z\"\n\n// date.toLocaleString();\n// // \"3/16/2030, 2:25:00 PM\"\n\n// date.getTime();\n// // 1899894300000\n//\n//\n\n//\n//\n//                              Проміси\n//                              ------\n//\n// Promise(обіцянка, проміс) - об'єкт, що представляє поточний стан асинхронної операції.\n// Це обгортка для значення, невідомого на момент створення промісу.\n// Дозволяє обробляти результати асинхронних операцій таким чином, якби вони були синхронними:\n// замість кінцевого результату асинхронної операції, повертається своєрідна обіцянка\n// отримати результат у майбутньому.\n\n// Проміс може бути у трьох станах:\n\n// Очікування (pending) - початковий стан під час створення промісу.\n// Виконано (fulfilled) - операція виконана успішно з будь-яким результатом.\n// Відхилено (rejected) - операція відхилена з помилкою.\n//\n// ЦІКАВО\n// Коли проміс виконаний або відхилений, то кажуть, що він завершений(settled).\n// Це просто термін, який описує те, що проміс перебуває в будь - якому стані, крім очікування.\n//\n\n//\n// Відмінності промісу і callback-функції:\n\n// * Колбеки - це функції, обіцянки - це об'єкти.\n// * Колбеки передаються як аргументи з зовнішнього коду у внутрішній, а обіцянки повертаються\n// з внутрішнього коду у зовнішній.\n// * Колбеки обробляють успішне або неуспішне завершення операції, обіцянки нічого не обробляють.\n// * Колбеки можуть обробляти декілька подій, обіцянки пов'язані тільки з однією подією.\n//\n\n//\n//\n//                                  Створення\n//                                  ---------\n//\n// Проміс створюється як екземпляр класу Promise, який приймає функцію(executor), як аргумент\n// і відразу викликає її, ще до створення і повернення промісу.\n\n// const promise = new Promise((resolve, reject) => {\n// \t// Asynchronous operation\n// });\n\n//\n// Функція executor повідомляє екземпляр(проміс), коли і як операція, з якою він пов'язаний,\n// буде завершена.У ній можна виконувати будь - яку асинхронну операцію, після завершення якої,\n// потрібно викликати resolve() - у разі успішного виконання(стан fulfilled), або reject() -\n// у разі помилки(стан rejected).Значення, що повертається цій функції, ігнорується.\n\n// resolve(value) - функція для виклику у разі успішної операції.Переданий їй аргумент буде\n// значенням виконаного промісу.\n// reject(error) - функція для виклику у разі помилки.Переданий їй аргумент буде значенням\n// відхиленого промісу.\n//\n\n//\n// Change value of isSuccess variable to call resolve or reject\n// const isSuccess = true;\n\n// const promise = new Promise((resolve, reject) => {\n// \tsetTimeout(() => {\n// \t\tif (isSuccess) {\n// \t\t\tresolve(\"Success! Value passed to resolve function\");\n// \t\t} else {\n// \t\t\treject(\"Error! Error passed to reject function\");\n// \t\t}\n// \t}, 2000);\n// });\n\n// console.log(promise);\n//\n//\n\n//\n//\n//                              Метод then()\n//                              -----------\n//\n//  promise.then(onResolve, onReject)\n//\n// * onResolve(value) - буде викликана у разі успішного виконання промісу і отримає його\n// результат як аргумент.\n// * onReject(error) - буде викликана у разі виконання промісу з помилкою і отримає її\n// як аргумент.\n//\n// У прикладі, callback - функція onResolve буде викликана через дві секунди, якщо обіцянка\n// успішно виконається, а onReject буде викликана через дві секунди у тому разі, якщо\n// обіцянка виконається з помилкою.\n\n// Change value of isSuccess variable to call resolve or reject\n// const isSuccess = true;\n\n// const promise = new Promise((resolve, reject) => {\n// \tsetTimeout(() => {\n// \t\tif (isSuccess) {\n// \t\t\tresolve(\"Success! Value passed to resolve function\");\n// \t\t} else {\n// \t\t\treject(\"Error! Error passed to reject function\");\n// \t\t}\n// \t}, 2000);\n// });\n\n// // Will run first\n// console.log(\"Before promise.then()\");\n\n// // Registering promise callbacks\n// promise.then(\n// \t// onResolve will run third or not at all\n// \tvalue => {\n// \t\tconsole.log(\"onResolve call inside promise.then()\");\n// \t\tconsole.log(value); // \"Success! Value passed to resolve function\"\n// \t},\n// \t// onReject will run third or not at all\n// \terror => {\n// \t\tconsole.log(\"onReject call inside promise.then()\");\n// \t\tconsole.log(error); // \"Error! Error passed to reject function\"\n// \t},\n// );\n\n// // Will run second\n// console.log(\"After promise.then()\");\n//\n//\n\n//\n//\n//                                  Метод catch()\n//                                  ------------\n//\n//          promise.catch(error => {\n//          \t// Promise rejected\n//          });\n//\n// Колбек-функція буде викликана у разі виконання промісу з помилкою, і отримає її як аргумент.\n\n// Change value of isSuccess variable to call resolve or reject\n// const isSuccess = true;\n// const isSuccess = false;\n\n// const promise = new Promise((resolve, reject) => {\n// \tsetTimeout(() => {\n// \t\tif (isSuccess) {\n// \t\t\tresolve(\"Success! Value passed to resolve function\");\n// \t\t} else {\n// \t\t\treject(\"Error! Error passed to reject function\");\n// \t\t}\n// \t}, 2000);\n// });\n\n// promise\n// \t.then(value => {\n// \t\tconsole.log(value);\n// \t})\n// \t.catch(error => {\n// \t\tconsole.log(error);\n// \t});\n//\n//\n\n//\n//\n//                                  Метод finally()\n//                                  --------------\n//\n// Цей метод може бути корисним, якщо необхідно виконати код після того, як обіцянка буде\n// дозволена(fulfilled або rejected), незалежно від результату.Дозволяє уникнути дублювання\n// коду в обробниках then() і catch ().\n//\n//            promise.finally(() => {\n//\t            // Promise fulfilled or rejected\n//           });\n//\n// Колбек - функція не отримає жодних аргументів, оскільки неможливо визначити - виконана чи\n// відхилена обіцянка.Тут буде виконуватися код, який необхідно запустити в будь - якому разі.\n\n// Change value of isSuccess variable to call resolve or reject\n// const isSuccess = true;\n// const isSuccess = false;\n\n// const promise = new Promise((resolve, reject) => {\n// \tsetTimeout(() => {\n// \t\tif (isSuccess) {\n// \t\t\tresolve(\"Success! Value passed to resolve function\");\n// \t\t} else {\n// \t\t\treject(\"Error! Error passed to reject function\");\n// \t\t}\n// \t}, 2000);\n// });\n\n// promise\n// \t.then(value => console.log(value)) // \"Success! Value passed to resolve function\"\n// \t.catch(error => console.log(error)) // \"Error! Error passed to reject function\"\n// \t.finally(() => console.log(\"Promise settled\")); // \"Promise settled\"\n//\n//\n\n//\n//\n//                          Ланцюжки промісів\n//                          -----------------\n//\n// const promise = new Promise((resolve, reject) => {\n// \tsetTimeout(() => {\n// \t\tresolve(5);\n// \t}, 2000);\n// });\n\n// promise\n// \t.then(value => {\n// \t\tconsole.log(value); // 5\n// \t\treturn value * 2;\n// \t})\n// \t.then(value => {\n// \t\tconsole.log(value); // 10\n// \t\treturn value * 3;\n// \t})\n// \t.then(value => {\n// \t\tconsole.log(value); // 30\n// \t})\n// \t.catch(error => {\n// \t\tconsole.log(error);\n// \t})\n// \t.finally(() => {\n// \t\tconsole.log(\"Final task\");\n// \t});\n//\n//\n\n//\n//\n//                          Промісифікація функцій\n//                          ----------------------\n//\n// Уявімо, що у нас є асинхронна функція, яка виконує якусь асинхронну операцію, наприклад,\n// запит на сервер.Для того щоб обробити результат, її доведеться спроектувати таким\n// чином, що вона буде очікувати на два колбеки - для успішного запиту і для помилки.\n//\n// const fetchUserFromServer = (username, onSuccess, onError) => {\n// \tconsole.log(`Fetching data for ${username}`);\n\n// \tsetTimeout(() => {\n// \t\t// Change value of isSuccess variable to simulate request status\n// \t\t// const isSuccess = true;\n// \t\tconst isSuccess = false;\n\n// \t\tif (isSuccess) {\n// \t\t\tonSuccess(\"success value\");\n// \t\t} else {\n// \t\t\tonError(\"error\");\n// \t\t}\n// \t}, 2000);\n// };\n\n// const onFetchSuccess = user => {\n// \tconsole.log(user);\n// };\n\n// const onFetchError = error => {\n// \tconsole.error(error);\n// };\n\n// fetchUserFromServer(\"Mango\", onFetchSuccess, onFetchError);\n//\n//\n\n//\n//\n//                          Промісифікація\n//                          --------------\n//\n// Промісифікація - це перетворення функції з колбеками таким чином, щоб вона не приймала\n// колбеки, а повертала проміс.\n\n// const fetchUserFromServer = username => {\n// \treturn new Promise((resolve, reject) => {\n// \t\tconsole.log(`Fetching data for ${username}`);\n\n// \t\tsetTimeout(() => {\n// \t\t\t// Change value of isSuccess variable to simulate request status\n// \t\t\tconst isSuccess = true;\n\n// \t\t\tif (isSuccess) {\n// \t\t\t\tresolve(\"success value\");\n// \t\t\t} else {\n// \t\t\t\treject(\"error\");\n// \t\t\t}\n// \t\t}, 2000);\n// \t});\n// };\n\n// fetchUserFromServer(\"Mango\")\n// \t.then(user => console.log(user))\n// \t.catch(error => console.error(error));\n//\n//\n\n//\n//\n//                              Методи класу Promise\n//                              -------------------\n//\n//                                  Promise.all()\n//                                      --------\n//\n// Приймає масив промісів, очікує їх виконання і повертає проміс.\n// Якщо всі проміси виконаються успішно, проміс, що повертається, перейде у стан fulfilled,\n// а його значенням буде масив результатів виконання кожного промісу.\n// У разі, коли хоча б один з промісів буде відхилений, проміс, що повертається,\n// перейде у стан rejected, а його значенням буде помилка.\n//\n// Promise.all([promise1, promise2, promise3, ...])\n//\n// const makePromise = (text, delay) => {\n// \treturn new Promise(resolve => {\n// \t\tsetTimeout(() => resolve(text), delay);\n// \t});\n// };\n\n// const promiseA = makePromise(\"promiseA value\", 1000);\n// const promiseB = makePromise(\"promiseB value\", 3000);\n\n// Promise.all([promiseA, promiseB])\n// \t.then(value => console.log(value)) //[\"promiseA value\", \"promiseB value\"]\n// \t.catch(error => console.log(error));\n//\n//\n\n//\n//\n//                          Promise.race()\n//                          -------------\n//\n// Повертає виконаний або відхилений проміс, залежно від того, з яким результатом завершиться\n// «найшвидший» з переданих промісів, зі значенням або причиною його відхилення.\n//\n//              Promise.race([promise1, promise2, promise3, ...])\n//\n// Коли хоча б один проміс з масиву виконається або буде відхилений, проміс, що повертається,\n// перейде у стан resolved або rejected, а всі інші будуть відкинуті.\n//\n// const makePromise = (text, delay) => {\n// \treturn new Promise(resolve => {\n// \t\tsetTimeout(() => resolve(text), delay);\n// \t});\n// };\n\n// const promiseA = makePromise(\"promiseA value\", 1000);\n// const promiseB = makePromise(\"promiseB value\", 3000);\n\n// Promise.race([promiseA, promiseB])\n// \t.then(value => console.log(value)) // \"promiseA value\"\n// \t.catch(error => console.log(error));\n//\n//\n\n//\n//\n//                  Promise.resolve() і Promise.reject()\n//                  -----------------------------------\n//\n// Статичні методи для створення промісів, що миттєво успішно виконуються або відхиляються.\n// Працюють аналогічно new Promise() за винятком можливості вказати затримку, але мають\n// коротший синтаксис.\n\n// // Fulfilled promise\n// new Promise(resolve => resolve(\"success value\")).then(value => console.log(value));\n\n// Promise.resolve(\"success value\").then(value => console.log(value));\n\n// // Rejected promise\n// new Promise((resolve, reject) => reject(\"error\")).catch(error => console.error(error));\n\n// Promise.reject(\"error\").catch(error => console.error(error));\n//\n//\n\n//\n//                      Refactoring\n//\n// const makeGreeting = guestName => {\n// \tif (guestName === \"\" || guestName === undefined) {\n// \t\treturn {\n// \t\t\tsuccess: false,\n// \t\t\tmessage: \"Guest name must not be empty\",\n// \t\t};\n// \t}\n\n// \treturn {\n// \t\tsuccess: true,\n// \t\tmessage: `Welcome ${guestName}`,\n// \t};\n// };\n\n// const result = makeGreeting(\"Mango\");\n\n// if (result.success) {\n// \tconsole.log(result.message);\n// } else {\n// \tconsole.error(result.message);\n// }\n//\n\n//\n\n// const makeGreeting = (guestName, onSuccess, onError) => {\n// \tif (guestName === \"\" || guestName === undefined) {\n// \t\treturn onError(\"Guest name must not be empty\");\n// \t}\n// \tonSuccess(`Welcome ${guestName}`);\n// };\n\n// makeGreeting(\n// \t\"Mango\",\n// \tgreeting => console.log(greeting),\n// \terror => console.error(error),\n// );\n//\n//\n// Останнім кроком буде промісифікація функції makeGreeting() для того, щоб повністю\n// усунути її залежність від зовнішнього коду.\n\n// const makeGreeting = guestName => {\n// \tif (guestName === \"\" || guestName === undefined) {\n// \t\treturn Promise.reject(\"Guest name must not be empty\");\n// \t}\n\n// \treturn Promise.resolve(`Welcome ${guestName}`);\n// };\n\n// makeGreeting(\"Mango\")\n// \t.then(greeting => console.log(greeting))\n// \t.catch(error => console.error(error));\n//\n//\n\n//\n//\n// Promise.resolve().then(() => console.log(\"Hey!\"));\n// console.log(\"Yo!\");\n//\n//\n\n//                                              -----------------------\n//\n//\n// const button = document.querySelector(\".btn\");\n\n// button.addEventListener(\"click\", () => {\n// \tPromise.resolve().then(() => console.log(\"Microtask1\"));\n// \tconsole.log(\"Listener1\");\n// });\n\n// button.addEventListener(\"click\", () => {\n// \tPromise.resolve().then(() => console.log(\"Microtask2\"));\n// \tconsole.log(\"Listener2\");\n// });\n\n// button.click();\n//\n//\n\n//                                              --------------------\n//\n//\n// const link = document.querySelector(\".link\");\n// const nextClick = new Promise(resolve => {\n// \tlink.addEventListener(\"click\", resolve, { once: true });\n// });\n\n// nextClick.then(e => {\n// \te.preventDefault();\n// \t// Handle event\n// });\n\n// link.click();\n//\n//\n\n//                                      ------------------------\n//\n//\n// console.log(\"script start\");\n\n// setTimeout(function () {\n// \tconsole.log(\"setTimeout\");\n// }, 0);\n\n// Promise.resolve()\n// \t.then(function () {\n// \t\tconsole.log(\"promise1\");\n// \t})\n// \t.then(function () {\n// \t\tconsole.log(\"promise2\");\n// \t});\n\n// console.log(\"script end\");\n\n/*\nscript start\nscript end\npromise1\npromise2\nsetTimeout\n*/\n//\n//\n\n//                      setTimeout() vs Promise\n//\n//\n// Let's get hold of those elements\n// var outer = document.querySelector(\".outer\");\n// var inner = document.querySelector(\".inner\");\n\n// // Let's listen for attribute changes on the\n// // outer element\n// new MutationObserver(function () {\n// \tconsole.log(\"mutate\");\n// }).observe(outer, {\n// \tattributes: true,\n// });\n\n// // Here's a click listener…\n// function onClick() {\n// \tconsole.log(\"click\");\n\n// \tsetTimeout(function () {\n// \t\tconsole.log(\"timeout\");\n// \t}, 0);\n\n// \tPromise.resolve().then(function () {\n// \t\tconsole.log(\"promise\");\n// \t});\n\n// \touter.setAttribute(\"data-random\", Math.random());\n// }\n\n// // …which we'll attach to both elements\n// inner.addEventListener(\"click\", onClick);\n// outer.addEventListener(\"click\", onClick);\n\n// inner.click();\n//\n//\n\n//\n//\n//                                        Репета\n//                                        ------\n//\n//                          setTimeout()\n//                          ------------\n//\n// const logMessage = () => {\n// \tconsole.log(\"Лог при виклиці collback-функції через 3 сек\");\n// };\n// console.log(\"До виклику setTimeout\");\n// setTimeout(\n// \tx => {\n// \t\tconsole.log(x);\n// \t\tconsole.log(\"Виклик setTimeout\");\n// \t},\n// \t2000,\n// \t3,\n// );\n// console.log(\"Після виклику setTimeout\");\n//\n//\n\n//\n//\n//                          clearTimeout()\n//                          ------------\n//\n// const logger = time => {\n// \tconsole.log(`Лог через ${time}ms, бо не відмінили таймаут`);\n// };\n// setTimeout(logger, 2000, 2000);\n// const shouldCancelTimer = Math.random() > 0.3;\n\n// console.log(shouldCancelTimer);\n\n// if (shouldCancelTimer) {\n// \tclearTimeout(shouldCancelTimer);\n// }\n//\n//\n\n//\n//\n//                          setInterval()\n//                          ------------\n//\n// const logger = time => console.log(`Лог кожні ${time}ms - ${Date.now()}`);\n\n// console.log(\"До виклику setInterval\");\n// setInterval(logger, 2000, 2000);\n// console.log(\"Після виклику setInterval\");\n//\n//\n\n//\n//\n//                          clearInterval()\n//                          ------------\n//\n// const intervalId = setInterval(logger, 2000, 2000);\n\n// const shouldCancelInterval = Math.random() > 0.3;\n\n// console.log(shouldCancelInterval);\n\n// if (shouldCancelInterval) {\n// \tclearInterval(intervalId);\n// }\n//\n//\n\n//\n//\n//\n// console.log(\"До виклику setTimeout\");\n// setTimeout(() => {\n// \tconsole.log(\"Виклик відкладеної ф-ції 1\");\n// }, 2000);\n// setTimeout(() => {\n// \tconsole.log(\"Виклик відкладеної ф-ції 2\");\n// }, 1000);\n// Promise.resolve().then(function () {\n// \tconsole.log(\"Promise 1\");\n// });\n// console.log(\"Після виклику setTimeout\");\n\n/*\nДо виклику setTimeout\nПісля виклику setTimeout\nPromise 1\nВиклик відкладеної ф-ції 2\nВиклик відкладеної ф-ції 1\n */\n//\n//\n\n//\n//\n// \t\t\t\t\t\tTask setTimeout().\n// \t\t\t\t\t\t-----------------\n//\n// const NOTIFICATION_DELAY = 3000;\n// let timeoutId = null;\n\n// const refs = {\n// \tnotification: document.querySelector(\".js-alert\"),\n// };\n\n// refs.notification.addEventListener(\"click\", onNotificationClick);\n\n// showNotification();\n\n// function onNotificationClick() {\n// \thideNotification();\n// \tclearTimeout(timeoutId);\n// }\n\n// function showNotification() {\n// \trefs.notification.classList.add(\"is-visible\");\n\n// \ttimeoutId = setTimeout(hideNotification, NOTIFICATION_DELAY);\n// }\n// function hideNotification() {\n// \tconsole.log(\"Закриваємо сповіщення!\");\n// \trefs.notification.classList.remove(\"is-visible\");\n// }\n//\n//\n\n//\n//\n// \t\t\t\t\t\tTask Subscription\n// \t\t\t\t\t\t-----------------\n//\n// const refs = {\n// \tmodal: document.querySelector(\"#subsription-modal\"),\n// };\n// const modal = new BSN.Modal(\"#subsription-modal\");\n// console.log(modal);\n\n// refs.modal.addEventListener(\"hide.bs.modal\", () => {\n// \tsetTimeout(() => {\n// \t\tconsole.log(\"Відкриваємо модалку\");\n// \t\tmodal.show();\n// \t}, PROMPT_DELAY);\n// });\n\n// const PROMPT_DELAY = 3000;\n// const MAX_PROMPT_ATTEMPTS = 3;\n\n// setTimeout(() => {\n// \tconsole.log(\"Відкриваємо модалку\");\n// \tmodal.show();\n// }, PROMPT_DELAY);\n// let promptCounter = 0;\n// let hasSubscribed = false;\n\n// const intervalId = setInterval(() => {\n// \tif (promptCounter === MAX_PROMPT_ATTEMPTS) {\n// \t\tconsole.log(\"Stopped interval\");\n// \t\tclearInterval(intervalId);\n// \t\treturn;\n// \t}\n\n// \tconsole.log(\"Subscribe to the newsletter - \" + Date.now());\n// \tpromptCounter += 1;\n// }, PROMPT_DELAY);\n"],"names":["console","log"],"version":3,"file":"assync.fce7beea.js.map"}